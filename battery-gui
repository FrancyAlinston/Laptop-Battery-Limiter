#!/usr/bin/env python3

import tkinter as tk
from tkinter import ttk, messagebox
import subprocess
import os
import threading
import time
import json
import urllib.request
import urllib.error
import datetime
import webbrowser
from pathlib import Path

class BatteryControlGUI:
    def __init__(self, root):
        self.root = root
        self.setup_window()
        self.setup_variables()
        self.create_widgets()
        self.update_battery_info()
        self.start_auto_refresh()
        # Start theme monitoring
        self.root.after(10000, self.check_theme_change)

    def setup_window(self):
        """Configure the main window"""
        self.root.title("Universal Battery Control Center")
        self.root.geometry("450x600")  # Fixed size optimized for content
        self.root.resizable(False, False)  # Disable resizing

        # Detect OS theme
        self.detect_os_theme()

        self.root.configure(bg=self.bg_color)

        # Configure styles
        self.setup_styles()

    def detect_os_theme(self):
        """Detect OS theme (dark/light mode) and set colors accordingly"""
        try:
            import subprocess

            # Default to light theme
            is_dark_theme = False

            # Get desktop environment info for better detection
            desktop_env = os.environ.get('XDG_CURRENT_DESKTOP', '').lower()
            desktop_session = os.environ.get('XDG_SESSION_DESKTOP', '').lower()
            window_manager = os.environ.get('WINDOW_MANAGER', '').lower()

            print(f"Desktop detection - Environment: {desktop_env}, Session: {desktop_session}, WM: {window_manager}")

            # === GTK-based Desktop Environments ===

            # GNOME/Ubuntu/Fedora detection (GTK 3/4)
            if not is_dark_theme:
                try:
                    # Try newer color-scheme method first (GTK 4 / GNOME 42+)
                    result = subprocess.run(['gsettings', 'get', 'org.gnome.desktop.interface', 'color-scheme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        color_scheme = result.stdout.strip().strip("'\"").lower()
                        if 'dark' in color_scheme or 'prefer-dark' in color_scheme:
                            is_dark_theme = True
                            print(f"Detected dark theme from GNOME color-scheme: {color_scheme}")
                        else:
                            print(f"Detected light theme from GNOME color-scheme: {color_scheme}")
                except Exception as e:
                    print(f"GNOME color-scheme detection failed: {e}")

            # Fallback to GTK theme detection (GTK 2/3)
            if not is_dark_theme:
                try:
                    result = subprocess.run(['gsettings', 'get', 'org.gnome.desktop.interface', 'gtk-theme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        theme_name = result.stdout.strip().strip("'\"").lower()
                        if 'dark' in theme_name or 'black' in theme_name or 'adwaita-dark' in theme_name:
                            is_dark_theme = True
                            print(f"Detected dark theme from GTK theme: {theme_name}")
                        else:
                            print(f"Detected light theme from GTK theme: {theme_name}")
                except Exception as e:
                    print(f"GTK theme detection failed: {e}")

            # === KDE Plasma (Qt-based) ===
            if not is_dark_theme:
                try:
                    # Try KDE 5 first
                    result = subprocess.run(['kreadconfig5', '--group', 'General', '--key', 'ColorScheme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        kde_scheme = result.stdout.strip().lower()
                        if 'dark' in kde_scheme or 'breeze dark' in kde_scheme or 'breezedark' in kde_scheme:
                            is_dark_theme = True
                            print(f"Detected dark theme from KDE 5: {kde_scheme}")
                        else:
                            print(f"Detected light theme from KDE 5: {kde_scheme}")
                except Exception as e:
                    print(f"KDE 5 theme detection failed: {e}")

            # Try KDE 4 fallback
            if not is_dark_theme:
                try:
                    result = subprocess.run(['kreadconfig', '--group', 'General', '--key', 'ColorScheme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        kde_scheme = result.stdout.strip().lower()
                        if 'dark' in kde_scheme or 'obsidian' in kde_scheme:
                            is_dark_theme = True
                            print(f"Detected dark theme from KDE 4: {kde_scheme}")
                        else:
                            print(f"Detected light theme from KDE 4: {kde_scheme}")
                except Exception as e:
                    print(f"KDE 4 theme detection failed: {e}")

            # === XFCE ===
            if not is_dark_theme:
                try:
                    result = subprocess.run(['xfconf-query', '-c', 'xsettings', '-p', '/Net/ThemeName'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        xfce_theme = result.stdout.strip().lower()
                        if 'dark' in xfce_theme or 'black' in xfce_theme or 'greybird-dark' in xfce_theme:
                            is_dark_theme = True
                            print(f"Detected dark theme from XFCE: {xfce_theme}")
                        else:
                            print(f"Detected light theme from XFCE: {xfce_theme}")
                except Exception as e:
                    print(f"XFCE theme detection failed: {e}")

                # Try XFCE window manager theme
                try:
                    result = subprocess.run(['xfconf-query', '-c', 'xfwm4', '-p', '/general/theme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        xfwm_theme = result.stdout.strip().lower()
                        if 'dark' in xfwm_theme or 'black' in xfwm_theme:
                            is_dark_theme = True
                            print(f"Detected dark theme from XFWM: {xfwm_theme}")
                except Exception as e:
                    print(f"XFWM theme detection failed: {e}")

            # === MATE ===
            if not is_dark_theme:
                try:
                    result = subprocess.run(['gsettings', 'get', 'org.mate.interface', 'gtk-theme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        mate_theme = result.stdout.strip().strip("'\"").lower()
                        if 'dark' in mate_theme or 'black' in mate_theme or 'blackmate' in mate_theme:
                            is_dark_theme = True
                            print(f"Detected dark theme from MATE: {mate_theme}")
                        else:
                            print(f"Detected light theme from MATE: {mate_theme}")
                except Exception as e:
                    print(f"MATE theme detection failed: {e}")

            # === Cinnamon ===
            if not is_dark_theme:
                try:
                    result = subprocess.run(['gsettings', 'get', 'org.cinnamon.desktop.interface', 'gtk-theme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        cinnamon_theme = result.stdout.strip().strip("'\"").lower()
                        if 'dark' in cinnamon_theme or 'black' in cinnamon_theme or 'mint-y-dark' in cinnamon_theme:
                            is_dark_theme = True
                            print(f"Detected dark theme from Cinnamon: {cinnamon_theme}")
                        else:
                            print(f"Detected light theme from Cinnamon: {cinnamon_theme}")
                except Exception as e:
                    print(f"Cinnamon theme detection failed: {e}")

            # === Budgie ===
            if not is_dark_theme:
                try:
                    result = subprocess.run(['gsettings', 'get', 'org.gnome.desktop.interface', 'gtk-theme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0 and 'budgie' in desktop_env:
                        budgie_theme = result.stdout.strip().strip("'\"").lower()
                        if 'dark' in budgie_theme or 'arc-dark' in budgie_theme or 'pocillo-dark' in budgie_theme:
                            is_dark_theme = True
                            print(f"Detected dark theme from Budgie: {budgie_theme}")
                        else:
                            print(f"Detected light theme from Budgie: {budgie_theme}")
                except Exception as e:
                    print(f"Budgie theme detection failed: {e}")

            # === Pantheon (elementary OS) ===
            if not is_dark_theme:
                try:
                    result = subprocess.run(['gsettings', 'get', 'org.gnome.desktop.interface', 'gtk-theme'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0 and 'pantheon' in desktop_env:
                        pantheon_theme = result.stdout.strip().strip("'\"").lower()
                        if 'dark' in pantheon_theme or 'elementary-dark' in pantheon_theme:
                            is_dark_theme = True
                            print(f"Detected dark theme from Pantheon: {pantheon_theme}")
                        else:
                            print(f"Detected light theme from Pantheon: {pantheon_theme}")
                except Exception as e:
                    print(f"Pantheon theme detection failed: {e}")

            # === LXDE/LXQt ===
            if not is_dark_theme:
                try:
                    # Try LXQt first
                    result = subprocess.run(['lxqt-config-appearance', '--help'],
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        # Check LXQt theme
                        config_file = os.path.expanduser('~/.config/lxqt/lxqt.conf')
                        if os.path.exists(config_file):
                            with open(config_file, 'r') as f:
                                content = f.read().lower()
                                if 'dark' in content or 'black' in content:
                                    is_dark_theme = True
                                    print(f"Detected dark theme from LXQt config")
                except Exception as e:
                    print(f"LXQt theme detection failed: {e}")

            # Try LXDE
            if not is_dark_theme:
                try:
                    config_file = os.path.expanduser('~/.config/lxsession/LXDE/desktop.conf')
                    if os.path.exists(config_file):
                        with open(config_file, 'r') as f:
                            content = f.read().lower()
                            if 'dark' in content or 'black' in content:
                                is_dark_theme = True
                                print(f"Detected dark theme from LXDE config")
                except Exception as e:
                    print(f"LXDE theme detection failed: {e}")

            # === Window Managers ===

            # i3/Sway
            if not is_dark_theme and ('i3' in window_manager or 'sway' in window_manager):
                try:
                    # Check i3 config
                    i3_config_paths = [
                        os.path.expanduser('~/.config/i3/config'),
                        os.path.expanduser('~/.i3/config'),
                        os.path.expanduser('~/.config/sway/config')
                    ]
                    for config_path in i3_config_paths:
                        if os.path.exists(config_path):
                            with open(config_path, 'r') as f:
                                content = f.read().lower()
                                if 'dark' in content or '#1e1e1e' in content or '#2e2e2e' in content:
                                    is_dark_theme = True
                                    print(f"Detected dark theme from i3/Sway config")
                                    break
                except Exception as e:
                    print(f"i3/Sway theme detection failed: {e}")

            # Awesome WM
            if not is_dark_theme and 'awesome' in window_manager:
                try:
                    awesome_config = os.path.expanduser('~/.config/awesome/rc.lua')
                    if os.path.exists(awesome_config):
                        with open(awesome_config, 'r') as f:
                            content = f.read().lower()
                            if 'dark' in content or 'beautiful.bg_normal = "#1e1e1e"' in content:
                                is_dark_theme = True
                                print(f"Detected dark theme from Awesome WM config")
                except Exception as e:
                    print(f"Awesome WM theme detection failed: {e}")

            # === Environment Variables ===
            if not is_dark_theme:
                try:
                    # Check various GTK theme environment variables
                    gtk_vars = [
                        'GTK_THEME',
                        'GTK2_RC_FILES',
                        'GTK_RC_FILES'
                    ]

                    for var in gtk_vars:
                        env_value = os.environ.get(var, '').lower()
                        if env_value and ('dark' in env_value or 'black' in env_value):
                            is_dark_theme = True
                            print(f"Detected dark theme from {var} env: {env_value}")
                            break

                    # Check Qt theme variables
                    qt_vars = [
                        'QT_STYLE_OVERRIDE',
                        'QT_QPA_PLATFORMTHEME'
                    ]

                    for var in qt_vars:
                        env_value = os.environ.get(var, '').lower()
                        if env_value and ('dark' in env_value or 'black' in env_value):
                            is_dark_theme = True
                            print(f"Detected dark theme from {var} env: {env_value}")
                            break

                except Exception as e:
                    print(f"Environment variable check failed: {e}")

            # === GTK Configuration Files ===
            if not is_dark_theme:
                try:
                    # Check GTK 3 settings
                    gtk3_settings = os.path.expanduser('~/.config/gtk-3.0/settings.ini')
                    if os.path.exists(gtk3_settings):
                        with open(gtk3_settings, 'r') as f:
                            content = f.read().lower()
                            if 'gtk-theme-name=.*dark' in content or 'gtk-application-prefer-dark-theme=true' in content:
                                is_dark_theme = True
                                print(f"Detected dark theme from GTK 3 settings")

                    # Check GTK 2 settings
                    gtk2_rc = os.path.expanduser('~/.gtkrc-2.0')
                    if os.path.exists(gtk2_rc):
                        with open(gtk2_rc, 'r') as f:
                            content = f.read().lower()
                            if 'dark' in content or 'black' in content:
                                is_dark_theme = True
                                print(f"Detected dark theme from GTK 2 settings")

                except Exception as e:
                    print(f"GTK config file check failed: {e}")

            # === X11 Resources ===
            if not is_dark_theme:
                try:
                    # Check .Xresources
                    xresources_paths = [
                        os.path.expanduser('~/.Xresources'),
                        os.path.expanduser('~/.Xdefaults')
                    ]

                    for xres_path in xresources_paths:
                        if os.path.exists(xres_path):
                            with open(xres_path, 'r') as f:
                                content = f.read().lower()
                                if ('*background:' in content and '#1' in content) or 'dark' in content:
                                    is_dark_theme = True
                                    print(f"Detected dark theme from X11 resources")
                                    break

                except Exception as e:
                    print(f"X11 resources check failed: {e}")

            # === Final fallback checks ===
            if not is_dark_theme:
                try:
                    # Check for common dark theme indicators in desktop session
                    dark_indicators = [
                        desktop_env,
                        desktop_session,
                        os.environ.get('DESKTOP_SESSION', '').lower(),
                        os.environ.get('GDMSESSION', '').lower()
                    ]

                    for indicator in dark_indicators:
                        if indicator and ('dark' in indicator or 'night' in indicator or 'black' in indicator):
                            is_dark_theme = True
                            print(f"Detected dark theme from desktop indicator: {indicator}")
                            break

                    # Check system time for auto dark mode (heuristic)
                    if not is_dark_theme:
                        import datetime
                        current_hour = datetime.datetime.now().hour
                        if current_hour < 6 or current_hour > 18:  # Between 6 PM and 6 AM
                            # Only apply this heuristic if we couldn't detect theme otherwise
                            print(f"No theme detected, applying time-based heuristic (evening/night)")
                            # Don't actually set dark theme based on time - too unreliable
                            # is_dark_theme = True

                except Exception as e:
                    print(f"Final fallback check failed: {e}")

            print(f"Final theme detection result: {'Dark' if is_dark_theme else 'Light'} theme")

            # Set theme colors
            if is_dark_theme:
                # Dark theme colors - improved palette
                self.bg_color = "#2e3440"          # Nord dark background
                self.card_color = "#3b4252"        # Nord slightly lighter
                self.accent_color = "#88c0d0"      # Nord accent blue
                self.text_color = "#eceff4"        # Nord light text
                self.secondary_text = "#d8dee9"    # Nord secondary text
                self.button_bg = "#5e81ac"         # Nord button blue
                self.button_fg = "#eceff4"         # Nord button text
                self.entry_bg = "#434c5e"          # Nord input background
                self.entry_fg = "#eceff4"          # Nord input text
                self.success_color = "#a3be8c"     # Nord green
                self.warning_color = "#ebcb8b"     # Nord yellow
                self.error_color = "#bf616a"       # Nord red
                self.border_color = "#4c566a"      # Nord border
            else:
                # Light theme colors - improved palette
                self.bg_color = "#fafafa"          # Light grey background
                self.card_color = "#ffffff"        # Pure white cards
                self.accent_color = "#1976d2"      # Material blue
                self.text_color = "#212121"        # Dark text
                self.secondary_text = "#757575"    # Grey text
                self.button_bg = "#1976d2"         # Material blue button
                self.button_fg = "#ffffff"         # White button text
                self.entry_bg = "#ffffff"          # White input background
                self.entry_fg = "#212121"          # Dark input text
                self.success_color = "#388e3c"     # Material green
                self.warning_color = "#f57c00"     # Material orange
                self.error_color = "#d32f2f"       # Material red
                self.border_color = "#e0e0e0"      # Light grey border

            self.is_dark_theme = is_dark_theme

        except Exception as e:
            # Fallback to light theme if detection fails
            self.bg_color = "#fafafa"
            self.card_color = "#ffffff"
            self.accent_color = "#1976d2"
            self.text_color = "#212121"
            self.secondary_text = "#757575"
            self.button_bg = "#1976d2"
            self.button_fg = "#ffffff"
            self.entry_bg = "#ffffff"
            self.entry_fg = "#212121"
            self.success_color = "#388e3c"
            self.warning_color = "#f57c00"
            self.error_color = "#d32f2f"
            self.border_color = "#e0e0e0"
            self.is_dark_theme = False
            print(f"Theme detection failed, using light theme: {e}")

    def setup_styles(self):
        """Setup custom styles for widgets following Ubuntu 24.04 design"""
        style = ttk.Style()

        # Use appropriate theme based on OS
        if self.is_dark_theme:
            # For dark themes, use a dark-friendly base
            try:
                style.theme_use('alt')  # alt theme works better with dark colors
            except:
                style.theme_use('clam')
        else:
            # For light themes, use clam for modern look
            try:
                style.theme_use('clam')
            except:
                style.theme_use('default')

        # Ubuntu 24.04 spacing and dimensions
        ubuntu_padding = 16
        ubuntu_button_height = 40
        ubuntu_button_padding = (20, 10)
        ubuntu_border_radius = 8

        # Configure theme-aware styles
        style.configure('Dark.TFrame',
                       background=self.bg_color,
                       relief='flat',
                       borderwidth=0)

        style.configure('Card.TFrame',
                       background=self.card_color,
                       relief='solid' if self.is_dark_theme else 'raised',
                       borderwidth=1 if self.is_dark_theme else 1,
                       padding=ubuntu_padding)

        style.configure('Dark.TLabel',
                       background=self.bg_color,
                       foreground=self.text_color,
                       font=('Ubuntu', 12))  # Ubuntu font

        style.configure('Title.TLabel',
                       background=self.bg_color,
                       foreground=self.text_color,
                       font=('Ubuntu', 20, 'bold'))

        style.configure('Card.TLabel',
                       background=self.card_color,
                       foreground=self.text_color,
                       font=('Ubuntu', 12))

        style.configure('Secondary.TLabel',
                       background=self.card_color,
                       foreground=self.secondary_text,
                       font=('Ubuntu', 11))

        style.configure('Accent.TLabel',
                       background=self.card_color,
                       foreground=self.accent_color,
                       font=('Ubuntu', 14, 'bold'))

        style.configure('Large.TLabel',
                       background=self.card_color,
                       foreground=self.text_color,
                       font=('Ubuntu', 16, 'bold'))

        # Ubuntu 24.04 Primary button style
        style.configure('Primary.TButton',
                       background=self.button_bg,
                       foreground=self.button_fg,
                       font=('Ubuntu', 12, 'bold'),
                       focuscolor='none',
                       borderwidth=0,
                       padding=ubuntu_button_padding,
                       relief='flat')

        # Primary button hover effects
        primary_hover = "#4a7bc8" if self.is_dark_theme else "#1565c0"
        primary_pressed = "#3a6bb8" if self.is_dark_theme else "#0d47a1"
        style.map('Primary.TButton',
                 background=[('active', primary_hover),
                           ('pressed', primary_pressed)],
                 relief=[('pressed', 'sunken'),
                        ('active', 'flat')])

        # Ubuntu 24.04 Secondary button style
        style.configure('Secondary.TButton',
                       background=self.card_color,
                       foreground=self.text_color,
                       font=('Ubuntu', 12),
                       focuscolor='none',
                       borderwidth=2,
                       padding=ubuntu_button_padding,
                       relief='solid')

        style.map('Secondary.TButton',
                 background=[('active', self.border_color),
                           ('pressed', self.border_color)],
                 bordercolor=[('active', self.accent_color),
                            ('pressed', self.accent_color)],
                 foreground=[('active', self.accent_color),
                           ('pressed', self.accent_color)])

        # Ubuntu 24.04 Accent button style (for important actions)
        style.configure('Accent.TButton',
                       background=self.accent_color,
                       foreground=self.button_fg,
                       font=('Ubuntu', 12, 'bold'),
                       focuscolor='none',
                       borderwidth=0,
                       padding=ubuntu_button_padding,
                       relief='flat')

        # Accent button hover effects
        accent_hover = "#1565c0" if not self.is_dark_theme else "#81c784"
        accent_pressed = "#0d47a1" if not self.is_dark_theme else "#66bb6a"
        style.map('Accent.TButton',
                 background=[('active', accent_hover),
                           ('pressed', accent_pressed)],
                 relief=[('pressed', 'sunken'),
                        ('active', 'flat')])

        # Ubuntu 24.04 Outline button style (for quick actions)
        outline_bg = self.card_color
        outline_fg = self.accent_color
        style.configure('Outline.TButton',
                       background=outline_bg,
                       foreground=outline_fg,
                       font=('Ubuntu', 12),
                       focuscolor='none',
                       borderwidth=2,
                       padding=(16, 8),
                       relief='solid')

        style.map('Outline.TButton',
                 background=[('active', self.accent_color),
                           ('pressed', self.accent_color)],
                 foreground=[('active', self.button_fg),
                           ('pressed', self.button_fg)],
                 bordercolor=[('active', self.accent_color),
                            ('pressed', self.accent_color)])

        # Scale style with Ubuntu design and better drag handle
        trough_color = self.border_color
        style.configure('Ubuntu.Horizontal.TScale',
                       background=self.card_color,
                       troughcolor=trough_color,
                       borderwidth=0,
                       sliderlength=28,
                       sliderrelief='raised',
                       lightcolor=self.accent_color,
                       darkcolor=self.accent_color,
                       focuscolor=self.accent_color,
                       troughrelief='sunken')

        style.map('Ubuntu.Horizontal.TScale',
                 background=[('active', self.accent_color)],
                 troughcolor=[('active', trough_color)])

        # Progressbar style with Ubuntu colors
        style.configure('Ubuntu.Horizontal.TProgressbar',
                       background=self.accent_color,
                       troughcolor=trough_color,
                       borderwidth=1,
                       lightcolor=self.accent_color,
                       darkcolor=self.accent_color)

        # Success/Warning/Error progressbar styles
        style.configure('Success.Horizontal.TProgressbar',
                       background=self.success_color,
                       troughcolor=trough_color,
                       borderwidth=1)

        style.configure('Warning.Horizontal.TProgressbar',
                       background=self.warning_color,
                       troughcolor=trough_color,
                       borderwidth=1)

        style.configure('Error.Horizontal.TProgressbar',
                       background=self.error_color,
                       troughcolor=trough_color,
                       borderwidth=1)

        # Ubuntu Radiobutton style
        style.configure('Ubuntu.TRadiobutton',
                       background=self.card_color,
                       foreground=self.text_color,
                       font=('Ubuntu', 12),
                       focuscolor='none',
                       borderwidth=0,
                       padding=(12, 6))

        style.map('Ubuntu.TRadiobutton',
                 background=[('active', self.card_color)],
                 foreground=[('active', self.accent_color)])

        # Entry style with Ubuntu design
        style.configure('Ubuntu.TEntry',
                       fieldbackground=self.entry_bg,
                       foreground=self.entry_fg,
                       borderwidth=2,
                       bordercolor=self.border_color,
                       insertcolor=self.text_color,
                       padding=(12, 8),
                       relief='solid')

        style.map('Ubuntu.TEntry',
                 bordercolor=[('focus', self.accent_color),
                            ('active', self.accent_color)])

        # Scrollbar style
        style.configure('Ubuntu.Vertical.TScrollbar',
                       background=self.border_color,
                       troughcolor=self.bg_color,
                       borderwidth=0,
                       arrowcolor=self.text_color,
                       darkcolor=self.border_color,
                       lightcolor=self.card_color)

        # Notebook style (for tabs if needed)
        style.configure('Ubuntu.TNotebook',
                       background=self.bg_color,
                       borderwidth=0,
                       tabmargins=[2, 5, 2, 0])

        style.configure('Ubuntu.TNotebook.Tab',
                       background=self.card_color,
                       foreground=self.text_color,
                       padding=(ubuntu_padding, 8),
                       borderwidth=1)

        style.map('Ubuntu.TNotebook.Tab',
                 background=[('selected', self.accent_color)],
                 foreground=[('selected', self.button_fg)])

    def setup_variables(self):
        """Initialize variables"""
        self.charge_limit_var = tk.IntVar(value=80)
        self.current_level = tk.StringVar(value="--")
        self.battery_status = tk.StringVar(value="--")
        self.power_mode = tk.StringVar(value="Performance")
        self.auto_refresh = True

        # Battery threshold file
        self.threshold_file = "/sys/class/power_supply/BAT0/charge_control_end_threshold"
        self.capacity_file = "/sys/class/power_supply/BAT0/capacity"
        self.status_file = "/sys/class/power_supply/BAT0/status"

        # Version info for updates
        self.current_version = "2.0.0"
        self.github_repo = "FrancyAlinston/Laptop-Battery-Limiter"
        self.release_channel = "stable"  # Can be "stable" or "beta"

        # Load settings
        self.load_settings()

    def create_widgets(self):
        """Create all GUI widgets with vertical scrolling only"""
        # Create a canvas and scrollbar for vertical scrolling only
        self.canvas = tk.Canvas(self.root, bg=self.bg_color, highlightthickness=0, width=450)
        self.scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas, style='Dark.TFrame')

        # Configure scrolling
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )

        # Create window with fixed width to prevent horizontal scrolling
        self.canvas_window = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        # Bind canvas resize to update scrollable frame width
        self.canvas.bind('<Configure>', self._on_canvas_configure)

        # Pack canvas and scrollbar
        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

        # Bind mouse wheel events for scrolling
        self.bind_mouse_wheel()

        # Initialize canvas width after creation
        self.root.after(10, self._initialize_canvas_width)

        # Main content frame with fixed width
        main_frame = ttk.Frame(self.scrollable_frame, style='Dark.TFrame')
        main_frame.pack(fill='both', expand=True, padx=15, pady=15)

        # Title
        title_label = ttk.Label(main_frame, text="üîã Battery Control Center", style='Title.TLabel')
        title_label.pack(pady=(0, 20))

        # Battery Status Card
        self.create_battery_status_card(main_frame)

        # Charging Limit Card
        self.create_charging_limit_card(main_frame)

        # Power Management Card
        self.create_power_management_card(main_frame)

        # Quick Actions Card
        self.create_quick_actions_card(main_frame)

        # Status Bar
        self.create_status_bar(main_frame)

    def create_battery_status_card(self, parent):
        """Create battery status information card"""
        card = ttk.Frame(parent, style='Card.TFrame')
        card.pack(fill='x', pady=(0, 15), padx=5, ipady=15)

        ttk.Label(card, text="‚ö° Battery Status", style='Accent.TLabel').pack(pady=(10, 5))

        # Battery level display
        level_frame = ttk.Frame(card, style='Card.TFrame')
        level_frame.pack(fill='x', padx=20, pady=10)

        ttk.Label(level_frame, text="Current Level:", style='Card.TLabel').pack(side='left')
        self.level_label = ttk.Label(level_frame, textvariable=self.current_level, style='Accent.TLabel')
        self.level_label.pack(side='right')

        # Battery status
        status_frame = ttk.Frame(card, style='Card.TFrame')
        status_frame.pack(fill='x', padx=20, pady=5)

        ttk.Label(status_frame, text="Status:", style='Card.TLabel').pack(side='left')
        self.status_label = ttk.Label(status_frame, textvariable=self.battery_status, style='Card.TLabel')
        self.status_label.pack(side='right')

        # Progress bar for battery level
        self.battery_progress = ttk.Progressbar(card, length=360, mode='determinate', style='Ubuntu.Horizontal.TProgressbar')
        self.battery_progress.pack(pady=10)

    def create_charging_limit_card(self, parent):
        """Create charging limit control card"""
        card = ttk.Frame(parent, style='Card.TFrame')
        card.pack(fill='x', pady=(0, 15), padx=5, ipady=15)

        ttk.Label(card, text="üéØ Charging Limit", style='Accent.TLabel').pack(pady=(10, 5))

        # Current limit display
        limit_display_frame = ttk.Frame(card, style='Card.TFrame')
        limit_display_frame.pack(fill='x', padx=20, pady=10)

        ttk.Label(limit_display_frame, text="Current Limit:", style='Card.TLabel').pack(side='left')
        self.limit_display = ttk.Label(limit_display_frame, text="80%", style='Accent.TLabel')
        self.limit_display.pack(side='right')

        # Slider for setting limit
        slider_frame = ttk.Frame(card, style='Card.TFrame')
        slider_frame.pack(fill='x', padx=20, pady=10)

        ttk.Label(slider_frame, text="50%", style='Card.TLabel').pack(side='left')

        self.limit_scale = ttk.Scale(slider_frame,
                                   from_=50, to=100,
                                   orient='horizontal',
                                   variable=self.charge_limit_var,
                                   style='Ubuntu.Horizontal.TScale',
                                   command=self.on_scale_change)
        self.limit_scale.pack(side='left', fill='x', expand=True, padx=10)

        ttk.Label(slider_frame, text="100%", style='Card.TLabel').pack(side='right')

        # Apply button with proper Ubuntu styling
        apply_btn = ttk.Button(card, text="Apply Charging Limit",
                              command=self.apply_charging_limit,
                              style='Primary.TButton')
        apply_btn.pack(pady=20, padx=20, fill='x')

        # Custom charging limit entry (for manual input)
        entry_frame = ttk.Frame(card, style='Card.TFrame')
        entry_frame.pack(fill='x', padx=20, pady=10)

        ttk.Label(entry_frame, text="Or enter manually:", style='Card.TLabel').pack(anchor='w', pady=(0, 5))

        input_row = ttk.Frame(entry_frame, style='Card.TFrame')
        input_row.pack(fill='x')

        self.manual_limit_entry = ttk.Entry(input_row, style='Ubuntu.TEntry', width=6)
        self.manual_limit_entry.pack(side='left', padx=(0, 8))

        ttk.Label(input_row, text="%", style='Card.TLabel').pack(side='left', padx=(0, 8))

        set_manual_btn = ttk.Button(input_row, text="Set",
                                   command=self.set_manual_limit,
                                   style='Secondary.TButton')
        set_manual_btn.pack(side='left')

    def create_power_management_card(self, parent):
        """Create power management controls"""
        card = ttk.Frame(parent, style='Card.TFrame')
        card.pack(fill='x', pady=(0, 15), padx=5, ipady=15)

        ttk.Label(card, text="‚öôÔ∏è Power Management", style='Accent.TLabel').pack(pady=(10, 5))

        # Power mode selection
        mode_frame = ttk.Frame(card, style='Card.TFrame')
        mode_frame.pack(fill='x', padx=20, pady=10)

        ttk.Label(mode_frame, text="Power Mode:", style='Card.TLabel').pack(anchor='w')

        mode_buttons_frame = ttk.Frame(mode_frame, style='Card.TFrame')
        mode_buttons_frame.pack(fill='x', pady=5)

        modes = [("Power Saver", "powersave"), ("Balanced", "balanced"), ("Performance", "performance")]
        for mode_name, mode_value in modes:
            btn = ttk.Radiobutton(mode_buttons_frame, text=mode_name,
                                variable=self.power_mode, value=mode_value,
                                style='Ubuntu.TRadiobutton',
                                command=lambda m=mode_value: self.set_power_mode(m))
            btn.pack(side='left', padx=12, pady=6)

    def create_quick_actions_card(self, parent):
        """Create quick action buttons"""
        card = ttk.Frame(parent, style='Card.TFrame')
        card.pack(fill='x', pady=(0, 15), padx=5, ipady=15)

        ttk.Label(card, text="üöÄ Quick Actions", style='Accent.TLabel').pack(pady=(10, 5))

        # Preset buttons with consistent Ubuntu styling
        presets_frame = ttk.Frame(card, style='Card.TFrame')
        presets_frame.pack(fill='x', padx=20, pady=10)

        presets = [
            ("60% Storage", 60),
            ("80% Daily", 80),
            ("100% Full", 100)
        ]

        for i, (text, value) in enumerate(presets):
            btn = ttk.Button(presets_frame, text=text,
                           command=lambda v=value: self.set_preset_limit(v),
                           style='Outline.TButton')
            btn.grid(row=0, column=i, padx=8, pady=6, sticky='ew')
            presets_frame.grid_columnconfigure(i, weight=1)

        # Additional actions with proper Ubuntu button styles
        actions_frame = ttk.Frame(card, style='Card.TFrame')
        actions_frame.pack(fill='x', padx=20, pady=10)

        # Row 1: Primary actions
        row1_frame = ttk.Frame(actions_frame, style='Card.TFrame')
        row1_frame.pack(fill='x', pady=(0, 10))

        refresh_btn = ttk.Button(row1_frame, text="üîÑ Refresh",
                               command=self.refresh_battery_info,
                               style='Secondary.TButton')
        refresh_btn.pack(side='left', padx=(0, 10), fill='x', expand=True)

        theme_btn = ttk.Button(row1_frame, text="üé® Theme",
                              command=self.refresh_theme,
                              style='Secondary.TButton')
        theme_btn.pack(side='left', padx=(0, 10), fill='x', expand=True)

        update_btn = ttk.Button(row1_frame, text="üîç Check Updates",
                              command=self.check_for_updates,
                              style='Secondary.TButton')
        update_btn.pack(side='left', fill='x', expand=True)

        # Row 2: Secondary actions
        row2_frame = ttk.Frame(actions_frame, style='Card.TFrame')
        row2_frame.pack(fill='x')

        channel_btn = ttk.Button(row2_frame, text="üîÑ Release Channel",
                               command=self.show_channel_settings,
                               style='Secondary.TButton')
        channel_btn.pack(side='left', padx=(0, 10), fill='x', expand=True)

        terminal_btn = ttk.Button(row2_frame, text="üìü Open Terminal CLI",
                                command=self.open_terminal_cli,
                                style='Secondary.TButton')
        terminal_btn.pack(side='left', fill='x', expand=True)

    def create_status_bar(self, parent):
        """Create status bar at bottom"""
        status_frame = ttk.Frame(parent, style='Dark.TFrame')
        status_frame.pack(fill='x', pady=(10, 0))

        self.status_text = ttk.Label(status_frame, text="Ready", style='Dark.TLabel')
        self.status_text.pack(side='left')

        self.last_update = ttk.Label(status_frame, text="", style='Dark.TLabel')
        self.last_update.pack(side='right')

    def on_scale_change(self, value):
        """Handle scale value change"""
        limit = int(float(value))
        self.limit_display.config(text=f"{limit}%")

    def check_root_access(self):
        """Check if we have root access"""
        return os.geteuid() == 0

    def run_command_with_sudo(self, command):
        """Run command with sudo if needed"""
        try:
            if self.check_root_access():
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
            else:
                # Use pkexec for GUI sudo prompt
                sudo_command = f"pkexec bash -c '{command}'"
                result = subprocess.run(sudo_command, shell=True, capture_output=True, text=True)

            return result.returncode == 0, result.stdout, result.stderr
        except Exception as e:
            return False, "", str(e)

    def apply_charging_limit(self):
        """Apply the charging limit"""
        limit = self.charge_limit_var.get()

        def apply_limit():
            self.status_text.config(text="Applying charging limit...")

            command = f"echo {limit} > {self.threshold_file}"
            success, stdout, stderr = self.run_command_with_sudo(command)

            if success:
                self.status_text.config(text=f"‚úÖ Charging limit set to {limit}%")
                self.refresh_battery_info()
                messagebox.showinfo("Success", f"Charging limit successfully set to {limit}%")
            else:
                self.status_text.config(text="‚ùå Failed to set charging limit")
                messagebox.showerror("Error", f"Failed to set charging limit:\n{stderr}")

        threading.Thread(target=apply_limit, daemon=True).start()

    def set_manual_limit(self):
        """Set charging limit from manual entry"""
        try:
            manual_value = self.manual_limit_entry.get().strip()
            if manual_value:
                limit = int(manual_value)
                if 50 <= limit <= 100:
                    self.charge_limit_var.set(limit)
                    self.limit_display.config(text=f"{limit}%")
                    self.manual_limit_entry.delete(0, tk.END)
                    self.apply_charging_limit()
                else:
                    messagebox.showerror("Invalid Input", "Please enter a value between 50 and 100")
            else:
                messagebox.showwarning("Empty Input", "Please enter a charging limit value")
        except ValueError:
            messagebox.showerror("Invalid Input", "Please enter a valid number")

    def set_preset_limit(self, value):
        """Set a preset charging limit"""
        self.charge_limit_var.set(value)
        self.limit_display.config(text=f"{value}%")
        self.apply_charging_limit()

    def set_power_mode(self, mode):
        """Set system power mode"""
        def set_mode():
            commands = {
                "powersave": "echo powersave | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor",
                "balanced": "echo ondemand | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor",
                "performance": "echo performance | sudo tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor"
            }

            if mode in commands:
                success, stdout, stderr = self.run_command_with_sudo(commands[mode])
                if success:
                    self.status_text.config(text=f"‚úÖ Power mode set to {mode}")
                else:
                    self.status_text.config(text="‚ùå Failed to set power mode")

        threading.Thread(target=set_mode, daemon=True).start()

    def refresh_battery_info(self):
        """Refresh battery information"""
        def update_info():
            try:
                # Get current battery level
                if os.path.exists(self.capacity_file):
                    with open(self.capacity_file, 'r') as f:
                        level = int(f.read().strip())
                    self.current_level.set(f"{level}%")
                    self.battery_progress['value'] = level

                    # Color code the battery level and progress bar
                    if level <= 20:
                        self.level_label.configure(foreground=self.error_color)
                        self.battery_progress.configure(style='Error.Horizontal.TProgressbar')
                    elif level <= 50:
                        self.level_label.configure(foreground=self.warning_color)
                        self.battery_progress.configure(style='Warning.Horizontal.TProgressbar')
                    else:
                        self.level_label.configure(foreground=self.success_color)
                        self.battery_progress.configure(style='Success.Horizontal.TProgressbar')

                # Get battery status
                if os.path.exists(self.status_file):
                    with open(self.status_file, 'r') as f:
                        status = f.read().strip()
                    self.battery_status.set(status)

                    # Set status icon
                    status_icons = {
                        "Charging": "üîå",
                        "Discharging": "üîã",
                        "Full": "‚úÖ",
                        "Not charging": "‚è∏Ô∏è"
                    }
                    icon = status_icons.get(status, "üîã")
                    self.status_label.configure(text=f"{icon} {status}")

                # Get current charging limit
                if os.path.exists(self.threshold_file):
                    with open(self.threshold_file, 'r') as f:
                        current_limit = int(f.read().strip())
                    self.charge_limit_var.set(current_limit)
                    self.limit_display.config(text=f"{current_limit}%")

                # Update last refresh time
                current_time = time.strftime("%H:%M:%S")
                self.last_update.config(text=f"Updated: {current_time}")

            except Exception as e:
                self.status_text.config(text=f"‚ùå Error reading battery info: {str(e)}")

        threading.Thread(target=update_info, daemon=True).start()

    def update_battery_info(self):
        """Initial battery info update"""
        self.refresh_battery_info()

    def start_auto_refresh(self):
        """Start automatic refresh of battery info"""
        def auto_refresh():
            while self.auto_refresh:
                self.refresh_battery_info()
                time.sleep(30)  # Refresh every 30 seconds

        threading.Thread(target=auto_refresh, daemon=True).start()

    def open_terminal_cli(self):
        """Open terminal with CLI tool"""
        try:
            subprocess.Popen(['gnome-terminal', '--', 'bash', '-c', 'battery-cli; read -p "Press Enter to close..."'])
        except:
            try:
                subprocess.Popen(['xterm', '-e', 'bash -c "battery-cli; read -p \\"Press Enter to close...\\""'])
            except:
                messagebox.showinfo("Info", "Please run 'battery-cli' in your terminal")

    def check_for_updates(self):
        """Check for updates from GitHub"""
        def check_updates():
            try:
                # Update status
                channel_name = "Beta" if self.release_channel == "beta" else "Stable"
                self.status_text.config(text=f"üîç Checking for {channel_name} updates...")

                # GitHub API URL with release channel support
                if self.release_channel == "beta":
                    # For beta, check all releases including pre-releases
                    api_url = f"https://api.github.com/repos/{self.github_repo}/releases"
                else:
                    # For stable, check only latest stable release
                    api_url = f"https://api.github.com/repos/{self.github_repo}/releases/latest"

                # Make request to GitHub API
                with urllib.request.urlopen(api_url, timeout=10) as response:
                    if response.getcode() == 200:
                        data = json.loads(response.read().decode())

                        if self.release_channel == "beta":
                            # Find the latest release (including pre-releases)
                            if isinstance(data, list) and len(data) > 0:
                                latest_release = data[0]  # First is most recent
                            else:
                                raise Exception("No releases found")
                        else:
                            latest_release = data

                        latest_version = latest_release.get('tag_name', '').lstrip('v')
                        release_url = latest_release.get('html_url', '')
                        release_notes = latest_release.get('body', 'No release notes available.')
                        is_prerelease = latest_release.get('prerelease', False)

                        # Compare versions
                        if self.compare_versions(latest_version, self.current_version):
                            # New version available
                            channel_info = " (Beta)" if is_prerelease else " (Stable)"
                            self.root.after(0, lambda: self.show_update_dialog(latest_version + channel_info, release_url, release_notes))
                        else:
                            # Up to date
                            channel_name = "Beta" if self.release_channel == "beta" else "Stable"
                            self.root.after(0, lambda: messagebox.showinfo(
                                "Up to Date",
                                f"You have the latest {channel_name} version ({self.current_version})"
                            ))
                    else:
                        raise Exception("Failed to fetch release information")

            except urllib.error.URLError:
                self.root.after(0, lambda: messagebox.showerror(
                    "Update Check Failed",
                    "No internet connection or GitHub unavailable"
                ))
            except Exception as e:
                self.root.after(0, lambda: messagebox.showerror(
                    "Update Check Failed",
                    f"Error: {str(e)}"
                ))
            finally:
                self.root.after(0, lambda: self.status_text.config(text="Ready"))

        # Run check in background thread
        threading.Thread(target=check_updates, daemon=True).start()

    def compare_versions(self, version1, version2):
        """Compare two version strings. Returns True if version1 > version2"""
        try:
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]

            # Pad shorter version with zeros
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))

            return v1_parts > v2_parts
        except:
            return False

    def show_update_dialog(self, latest_version, release_url, release_notes):
        """Show update available dialog"""
        update_window = tk.Toplevel(self.root)
        update_window.title("Update Available")
        update_window.geometry("500x400")
        update_window.configure(bg=self.bg_color)
        update_window.resizable(False, False)

        # Make it modal
        update_window.transient(self.root)
        update_window.grab_set()

        # Center the window
        update_window.geometry("+%d+%d" % (
            self.root.winfo_rootx() + 50,
            self.root.winfo_rooty() + 50
        ))

        main_frame = ttk.Frame(update_window, style='Dark.TFrame')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)

        # Title
        title_label = ttk.Label(main_frame, text="üéâ Update Available!", style='Title.TLabel')
        title_label.pack(pady=(0, 10))

        # Version info
        version_frame = ttk.Frame(main_frame, style='Card.TFrame')
        version_frame.pack(fill='x', pady=10, padx=10, ipady=10)

        ttk.Label(version_frame, text=f"Current Version: {self.current_version}", style='Card.TLabel').pack(anchor='w', padx=10)
        ttk.Label(version_frame, text=f"Latest Version: {latest_version}", style='Accent.TLabel').pack(anchor='w', padx=10)

        # Release notes
        notes_label = ttk.Label(main_frame, text="Release Notes:", style='Dark.TLabel')
        notes_label.pack(anchor='w', pady=(10, 5))

        # Text widget for release notes
        text_frame = ttk.Frame(main_frame, style='Card.TFrame')
        text_frame.pack(fill='both', expand=True, pady=5)

        text_widget = tk.Text(text_frame, height=8, wrap=tk.WORD,
                             bg=self.card_color, fg=self.text_color,
                             font=('Segoe UI', 9),
                             insertbackground=self.text_color,
                             selectbackground=self.accent_color,
                             selectforeground=self.card_color)
        scrollbar = ttk.Scrollbar(text_frame, orient="vertical", command=text_widget.yview)
        text_widget.configure(yscrollcommand=scrollbar.set)

        text_widget.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        scrollbar.pack(side="right", fill="y", pady=5)

        text_widget.insert(tk.END, release_notes)
        text_widget.config(state=tk.DISABLED)

        # Buttons with improved alignment
        button_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        button_frame.pack(fill='x', pady=(20, 0))

        def download_update():
            import webbrowser
            webbrowser.open(release_url)
            update_window.destroy()

        def close_dialog():
            update_window.destroy()

        download_btn = ttk.Button(button_frame, text="üîó Download Update",
                                 command=download_update, style='Primary.TButton')
        download_btn.pack(side='left', padx=10)

        close_btn = ttk.Button(button_frame, text="Close", command=close_dialog,
                              style='Secondary.TButton')
        close_btn.pack(side='right', padx=10)

    def show_channel_settings(self):
        """Show release channel settings dialog"""
        channel_window = tk.Toplevel(self.root)
        channel_window.title("Release Channel Settings")
        channel_window.geometry("400x300")
        channel_window.configure(bg=self.bg_color)
        channel_window.resizable(False, False)

        # Make it modal
        channel_window.transient(self.root)
        channel_window.grab_set()

        # Center the window
        channel_window.geometry("+%d+%d" % (
            self.root.winfo_rootx() + 50,
            self.root.winfo_rooty() + 50
        ))

        main_frame = ttk.Frame(channel_window, style='Dark.TFrame')
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)

        # Title
        title_label = ttk.Label(main_frame, text="Release Channel Settings", style='Title.TLabel')
        title_label.pack(pady=(0, 10))

        # Description
        desc_label = ttk.Label(main_frame, text="Choose which type of updates you want to receive:", style='Dark.TLabel')
        desc_label.pack(pady=(0, 20))

        # Channel selection
        self.channel_var = tk.StringVar(value=self.release_channel)

        # Stable option
        stable_frame = ttk.Frame(main_frame, style='Card.TFrame')
        stable_frame.pack(fill='x', pady=5, padx=10, ipady=10)

        stable_radio = ttk.Radiobutton(stable_frame, text="Stable Channel",
                                     variable=self.channel_var, value="stable",
                                     style='Card.TRadiobutton')
        stable_radio.pack(anchor='w', padx=10, pady=5)

        stable_desc = ttk.Label(stable_frame,
                              text="‚Ä¢ Stable, tested releases\n‚Ä¢ Recommended for most users\n‚Ä¢ Less frequent updates",
                              style='Card.TLabel')
        stable_desc.pack(anchor='w', padx=30, pady=(0, 5))

        # Beta option
        beta_frame = ttk.Frame(main_frame, style='Card.TFrame')
        beta_frame.pack(fill='x', pady=5, padx=10, ipady=10)

        beta_radio = ttk.Radiobutton(beta_frame, text="Beta Channel",
                                   variable=self.channel_var, value="beta",
                                   style='Card.TRadiobutton')
        beta_radio.pack(anchor='w', padx=10, pady=5)

        beta_desc = ttk.Label(beta_frame,
                            text="‚Ä¢ Early access to new features\n‚Ä¢ May contain bugs\n‚Ä¢ More frequent updates",
                            style='Card.TLabel')
        beta_desc.pack(anchor='w', padx=30, pady=(0, 5))

        # Current channel info
        current_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        current_frame.pack(fill='x', pady=10)

        current_label = ttk.Label(current_frame,
                                text=f"Current channel: {self.release_channel.title()}",
                                style='Dark.TLabel')
        current_label.pack()

        # Buttons with improved alignment
        button_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        button_frame.pack(fill='x', pady=(20, 0))

        def apply_settings():
            new_channel = self.channel_var.get()
            if new_channel != self.release_channel:
                self.release_channel = new_channel
                self.save_settings()
                messagebox.showinfo("Channel Changed",
                                  f"Release channel changed to {new_channel.title()}")
            channel_window.destroy()

        def cancel_settings():
            channel_window.destroy()

        apply_btn = ttk.Button(button_frame, text="Apply",
                             command=apply_settings, style='Primary.TButton')
        apply_btn.pack(side='left', padx=10)

        cancel_btn = ttk.Button(button_frame, text="Cancel", command=cancel_settings,
                              style='Secondary.TButton')
        cancel_btn.pack(side='right', padx=10)

    def save_settings(self):
        """Save settings to file"""
        try:
            import os
            config_dir = os.path.expanduser("~/.config/universal-battery-limiter")
            os.makedirs(config_dir, exist_ok=True)

            config_file = os.path.join(config_dir, "settings.conf")
            with open(config_file, 'w') as f:
                f.write(f"release_channel={self.release_channel}\n")
        except Exception as e:
            print(f"Failed to save settings: {e}")

    def load_settings(self):
        """Load settings from file"""
        try:
            import os
            config_file = os.path.expanduser("~/.config/universal-battery-limiter/settings.conf")
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    for line in f:
                        if line.startswith("release_channel="):
                            self.release_channel = line.split("=")[1].strip()
        except Exception as e:
            print(f"Failed to load settings: {e}")

    def refresh_theme(self):
        """Refresh the theme in case the user changed their system theme"""
        try:
            # Re-detect theme
            self.detect_os_theme()

            # Re-apply styles
            self.setup_styles()

            # Update window background
            self.root.configure(bg=self.bg_color)

            # Update canvas background if it exists
            if hasattr(self, 'canvas'):
                self.canvas.configure(bg=self.bg_color)

            # Force a refresh of all widgets
            self.root.update_idletasks()

            # Update scroll region
            if hasattr(self, 'canvas'):
                self.update_scroll_region()

            print("Theme refreshed successfully")

        except Exception as e:
            print(f"Failed to refresh theme: {e}")

    def check_theme_change(self):
        """Check if the system theme has changed"""
        try:
            # Store current theme state
            old_theme = self.is_dark_theme

            # Re-detect theme
            self.detect_os_theme()

            # If theme changed, refresh everything
            if old_theme != self.is_dark_theme:
                print(f"Theme changed from {'dark' if old_theme else 'light'} to {'dark' if self.is_dark_theme else 'light'}")
                self.refresh_theme()

        except Exception as e:
            print(f"Failed to check theme change: {e}")

        # Schedule next check in 10 seconds
        self.root.after(10000, self.check_theme_change)

    def bind_mouse_wheel(self):
        """Bind mouse wheel events for scrolling"""
        # Bind mouse wheel to canvas
        self.canvas.bind("<MouseWheel>", self._on_mousewheel)  # Windows and MacOS
        self.canvas.bind("<Button-4>", self._on_mousewheel)    # Linux scroll up
        self.canvas.bind("<Button-5>", self._on_mousewheel)    # Linux scroll down

        # Also bind to the root window to catch events anywhere
        self.root.bind("<MouseWheel>", self._on_mousewheel)
        self.root.bind("<Button-4>", self._on_mousewheel)
        self.root.bind("<Button-5>", self._on_mousewheel)

        # Bind keyboard scrolling
        self.root.bind("<Up>", self._on_key_scroll)
        self.root.bind("<Down>", self._on_key_scroll)
        self.root.bind("<Page_Up>", self._on_key_scroll)
        self.root.bind("<Page_Down>", self._on_key_scroll)
        self.root.bind("<Home>", self._on_key_scroll)
        self.root.bind("<End>", self._on_key_scroll)

        # Bind focus events to ensure scrolling works
        self.canvas.bind("<Enter>", self._on_enter)
        self.canvas.bind("<Leave>", self._on_leave)

        # Make canvas focusable
        self.canvas.focus_set()

    def _on_key_scroll(self, event):
        """Handle keyboard scrolling"""
        try:
            if not self.canvas.winfo_exists():
                return

            # Get scroll parameters
            total_height = self.canvas.bbox("all")
            if not total_height or len(total_height) < 4:
                return

            content_height = total_height[3] - total_height[1]
            visible_height = self.canvas.winfo_height()

            # Only scroll if content is larger than visible area
            if content_height <= visible_height:
                return

            # Handle different key types
            if event.keysym == "Up":
                self.canvas.yview_scroll(-1, "units")
            elif event.keysym == "Down":
                self.canvas.yview_scroll(1, "units")
            elif event.keysym == "Page_Up":
                self.canvas.yview_scroll(-1, "pages")
            elif event.keysym == "Page_Down":
                self.canvas.yview_scroll(1, "pages")
            elif event.keysym == "Home":
                self.canvas.yview_moveto(0)
            elif event.keysym == "End":
                self.canvas.yview_moveto(1)

        except Exception as e:
            print(f"Keyboard scroll error: {e}")

    def _on_mousewheel(self, event):
        """Handle mouse wheel scrolling"""
        try:
            # Determine scroll direction and amount
            if event.num == 4 or event.delta > 0:  # Scroll up
                scroll_amount = -1
            elif event.num == 5 or event.delta < 0:  # Scroll down
                scroll_amount = 1
            else:
                scroll_amount = 0

            # Only scroll if there's content to scroll
            if self.canvas.winfo_exists():
                # Get the current scroll region
                scroll_top = self.canvas.canvasy(0)
                scroll_bottom = self.canvas.canvasy(self.canvas.winfo_height())
                total_height = self.canvas.bbox("all")

                if total_height and len(total_height) >= 4:
                    content_height = total_height[3] - total_height[1]
                    visible_height = self.canvas.winfo_height()

                    # Only scroll if content is larger than visible area
                    if content_height > visible_height:
                        self.canvas.yview_scroll(scroll_amount, "units")

        except Exception as e:
            print(f"Mouse wheel scroll error: {e}")

    def _on_enter(self, event):
        """Handle mouse entering canvas"""
        self.canvas.focus_set()

    def _on_leave(self, event):
        """Handle mouse leaving canvas"""
        pass

    def update_scroll_region(self):
        """Update the scroll region when content changes"""
        try:
            self.root.update_idletasks()
            self.canvas.configure(scrollregion=self.canvas.bbox("all"))
            # Ensure the scrollable frame width matches canvas width
            canvas_width = self.canvas.winfo_width()
            if canvas_width > 1:  # Only update if canvas has been rendered
                self.canvas.itemconfig(self.canvas_window, width=canvas_width)
        except Exception as e:
            print(f"Scroll region update error: {e}")

    def _on_canvas_configure(self, event):
        """Handle canvas resize to update scrollable frame width"""
        try:
            # Update the scrollable frame width to match canvas width
            canvas_width = event.width
            self.canvas.itemconfig(self.canvas_window, width=canvas_width)
        except Exception as e:
            print(f"Canvas configure error: {e}")

    def _initialize_canvas_width(self):
        """Initialize canvas width to prevent horizontal scrolling"""
        try:
            # Set the scrollable frame width to match the available canvas width
            canvas_width = self.canvas.winfo_width()
            if canvas_width > 1:
                self.canvas.itemconfig(self.canvas_window, width=canvas_width)
            self.update_scroll_region()
        except Exception as e:
            print(f"Canvas width initialization error: {e}")

def main():
    root = tk.Tk()
    app = BatteryControlGUI(root)

    # Handle window close
    def on_closing():
        app.auto_refresh = False
        root.destroy()

    root.protocol("WM_DELETE_WINDOW", on_closing)
    root.mainloop()

if __name__ == "__main__":
    main()
