#!/usr/bin/env python3

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
gi.require_version('Notify', '0.7')

from gi.repository import Gtk, AppIndicator3, GObject, Notify
import subprocess
import threading
import time
import os
import json
import urllib.request
import urllib.error

# Import our enhanced animated icon manager
try:
    from enhanced_animated_icons import EnhancedAnimatedIconManager
    ANIMATIONS_AVAILABLE = True
    print("âœ¨ Enhanced animated icons available")
except ImportError:
    try:
        from animated_icons import AnimatedIconManager as EnhancedAnimatedIconManager
        ANIMATIONS_AVAILABLE = True
        print("ðŸ“± Basic animated icons available")
    except ImportError:
        ANIMATIONS_AVAILABLE = False
        print("âš ï¸ Animated icons not available, using static icons")

class BatteryLimitIndicator:
    def __init__(self):
        # Initialize notification
        Notify.init("Battery Limiter")

        # Create indicator
        self.indicator = AppIndicator3.Indicator.new(
            "battery-limiter",
            "battery",
            AppIndicator3.IndicatorCategory.HARDWARE
        )

        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
        self.indicator.set_menu(self.create_menu())

        # Initialize enhanced animated icon manager
        if ANIMATIONS_AVAILABLE:
            self.icon_manager = EnhancedAnimatedIconManager(self.indicator)
            print("âœ… Enhanced animated icons enabled")
        else:
            self.icon_manager = None
            print("â„¹ï¸ Using static system icons")

        # Battery files
        self.threshold_file = "/sys/class/power_supply/BAT0/charge_control_end_threshold"
        self.capacity_file = "/sys/class/power_supply/BAT0/capacity"
        self.status_file = "/sys/class/power_supply/BAT0/status"

        # Version info for updates
        self.current_version = "2.1.0"
        self.github_repo = "FrancyAlinston/Laptop-Battery-Limiter"
        self.release_channel = "stable"  # Can be "stable" or "beta"

        # Battery state tracking
        self.last_battery_level = 0
        self.last_battery_status = ""
        self.last_charge_limit = 80

        # Load settings
        self.load_settings()

        # Update indicator
        self.update_indicator()

        # Start update thread
        self.start_update_thread()

    def create_menu(self):
        menu = Gtk.Menu()

        # Battery status item
        self.status_item = Gtk.MenuItem()
        self.status_item.set_sensitive(False)
        menu.append(self.status_item)

        # Separator
        separator = Gtk.SeparatorMenuItem()
        menu.append(separator)

        # Quick presets
        presets = [
            ("ðŸ”‹ 60% (Storage)", 60),
            ("ðŸ”‹ 70% (Conservative)", 70),
            ("ðŸ”‹ 80% (Recommended)", 80),
            ("ðŸ”‹ 90% (Extended)", 90),
            ("ðŸ”‹ 100% (Full)", 100)
        ]

        for label, value in presets:
            item = Gtk.MenuItem(label=label)
            item.connect("activate", self.set_limit, value)
            menu.append(item)

        # Separator
        separator2 = Gtk.SeparatorMenuItem()
        menu.append(separator2)

        # Advanced options
        advanced_item = Gtk.MenuItem(label="ðŸ”§ Advanced Settings")
        advanced_item.connect("activate", self.open_gui)
        menu.append(advanced_item)

        cli_item = Gtk.MenuItem(label="ðŸ“Ÿ Open CLI")
        cli_item.connect("activate", self.open_cli)
        menu.append(cli_item)

        # Separator
        separator3 = Gtk.SeparatorMenuItem()
        menu.append(separator3)

        # Refresh
        refresh_item = Gtk.MenuItem(label="ðŸ”„ Refresh")
        refresh_item.connect("activate", self.refresh)
        menu.append(refresh_item)

        # Check for updates
        update_item = Gtk.MenuItem(label="ðŸ” Check for Updates")
        update_item.connect("activate", self.check_for_updates)
        menu.append(update_item)

        # Release channel settings
        channel_item = Gtk.MenuItem(label="ðŸ”„ Release Channel")
        channel_item.connect("activate", self.show_channel_settings)
        menu.append(channel_item)

        # About
        about_item = Gtk.MenuItem(label="â„¹ï¸ About")
        about_item.connect("activate", self.show_about)
        menu.append(about_item)

        # Exit
        exit_item = Gtk.MenuItem(label="âŒ Exit")
        exit_item.connect("activate", self.quit)
        menu.append(exit_item)

        menu.show_all()
        return menu

    def get_battery_info(self):
        try:
            limit = self.read_file(self.threshold_file, "N/A")
            level = self.read_file(self.capacity_file, "N/A")
            status = self.read_file(self.status_file, "N/A")
            return limit, level, status
        except:
            return "N/A", "N/A", "N/A"

    def read_file(self, filepath, default="N/A"):
        try:
            with open(filepath, 'r') as f:
                return f.read().strip()
        except:
            return default

    def update_indicator(self):
        limit, level, status = self.get_battery_info()

        # Update status item
        status_text = f"ðŸ”‹ {level}% ({status}) | Limit: {limit}%"
        self.status_item.set_label(status_text)

        # Update tooltip
        self.indicator.set_title(f"Battery: {level}% | Limit: {limit}%")
        
        # Update animated icon if available
        if self.icon_manager:
            # Only update icon if state changed (to avoid unnecessary animations)
            current_state = (level, status, limit)
            if not hasattr(self, '_last_icon_state') or self._last_icon_state != current_state:
                self._last_icon_state = current_state
                self.icon_manager.update_icon(level, status, limit)
        
        # Store current state
        self.last_battery_level = level
        self.last_battery_status = status
        self.last_charge_limit = limit

    def set_limit(self, widget, limit):
        def run_command():
            try:
                # Use pkexec for GUI authentication
                cmd = f"pkexec bash -c 'echo {limit} > {self.threshold_file}'"
                result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

                if result.returncode == 0:
                    GObject.idle_add(self.show_notification,
                                   "Battery Limit Set",
                                   f"Charging limit set to {limit}%")
                    GObject.idle_add(self.update_indicator)
                else:
                    GObject.idle_add(self.show_notification,
                                   "Error",
                                   "Failed to set battery limit")
            except Exception as e:
                GObject.idle_add(self.show_notification,
                               "Error",
                               f"Failed to set battery limit: {str(e)}")

        # Run in thread to avoid blocking UI
        thread = threading.Thread(target=run_command)
        thread.daemon = True
        thread.start()

    def show_notification(self, title, message):
        notification = Notify.Notification.new(title, message, "battery")
        notification.show()

    def open_gui(self, widget):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        gui_path = os.path.join(script_dir, "battery-gui")
        subprocess.Popen(["python3", gui_path])

    def open_cli(self, widget):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        cli_path = os.path.join(script_dir, "battery-cli")
        subprocess.Popen(["gnome-terminal", "--", "sudo", cli_path])

    def refresh(self, widget):
        self.update_indicator()
        self.show_notification("Refreshed", "Battery information updated")

    def check_for_updates(self, widget):
        def check_updates():
            try:
                # First, check if we're installed via package manager
                update_available, update_method = self.check_native_updates()

                if update_available:
                    # Native update available
                    GObject.idle_add(self.show_native_update_dialog, update_method)
                    return

                # Fallback to GitHub API check with release channel support
                if self.release_channel == "beta":
                    # For beta, check all releases including pre-releases
                    api_url = f"https://api.github.com/repos/{self.github_repo}/releases"
                else:
                    # For stable, check only latest stable release
                    api_url = f"https://api.github.com/repos/{self.github_repo}/releases/latest"

                # Make request to GitHub API
                with urllib.request.urlopen(api_url, timeout=10) as response:
                    if response.getcode() == 200:
                        data = json.loads(response.read().decode())
                        
                        if self.release_channel == "beta":
                            # Find the latest release (including pre-releases)
                            if isinstance(data, list) and len(data) > 0:
                                latest_release = data[0]  # First is most recent
                            else:
                                raise Exception("No releases found")
                        else:
                            latest_release = data
                        
                        latest_version = latest_release.get('tag_name', '').lstrip('v')
                        release_url = latest_release.get('html_url', '')
                        release_notes = latest_release.get('body', 'No release notes available.')
                        is_prerelease = latest_release.get('prerelease', False)

                        # Compare versions
                        if self.compare_versions(latest_version, self.current_version):
                            # New version available
                            channel_info = " (Beta)" if is_prerelease else " (Stable)"
                            GObject.idle_add(self.show_update_dialog, latest_version + channel_info, release_url, release_notes)
                        else:
                            # Up to date
                            channel_name = "Beta" if self.release_channel == "beta" else "Stable"
                            GObject.idle_add(self.show_notification,
                                           "Up to Date",
                                           f"You have the latest {channel_name} version ({self.current_version})")
                    else:
                        raise Exception("Failed to fetch release information")

            except urllib.error.URLError as e:
                GObject.idle_add(self.show_notification,
                               "Update Check Failed",
                               "No internet connection or GitHub unavailable")
            except Exception as e:
                GObject.idle_add(self.show_notification,
                               "Update Check Failed",
                               f"Error: {str(e)}")

        # Show checking notification
        channel_name = "Beta" if self.release_channel == "beta" else "Stable"
        self.show_notification("Checking for Updates", f"Checking {channel_name} channel...")

        # Run check in background thread
        thread = threading.Thread(target=check_updates)
        thread.daemon = True
        thread.start()

    def check_native_updates(self):
        """Check for updates via native package managers"""
        try:
            # Check if installed via APT (Ubuntu/Debian)
            result = subprocess.run(
                ["dpkg", "-l", "universal-battery-limiter"],
                capture_output=True, text=True, timeout=5
            )

            if result.returncode == 0:
                # Package is installed via APT
                # Check for updates
                apt_result = subprocess.run(
                    ["apt", "list", "--upgradable", "universal-battery-limiter"],
                    capture_output=True, text=True, timeout=10
                )

                if "universal-battery-limiter" in apt_result.stdout and "upgradable" in apt_result.stdout:
                    return True, "apt"

            # Check if installed via Snap
            snap_result = subprocess.run(
                ["snap", "list", "universal-battery-limiter"],
                capture_output=True, text=True, timeout=5
            )

            if snap_result.returncode == 0:
                # Check for snap updates
                snap_refresh = subprocess.run(
                    ["snap", "refresh", "--list"],
                    capture_output=True, text=True, timeout=10
                )

                if "universal-battery-limiter" in snap_refresh.stdout:
                    return True, "snap"

            return False, None

        except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
            return False, None

    def show_native_update_dialog(self, update_method):
        """Show native update available dialog"""
        if update_method == "apt":
            title = "Ubuntu System Update Available"
            message = ("A new version of Universal Battery Limiter is available through the Ubuntu package manager.\n\n"
                      "You can update using:\n"
                      "â€¢ Software Updater (recommended)\n"
                      "â€¢ Terminal: sudo apt update && sudo apt upgrade universal-battery-limiter\n\n"
                      "Would you like to open Software Updater?")
            command = ["gnome-software", "--mode=updates"]
        elif update_method == "snap":
            title = "Snap Store Update Available"
            message = ("A new version of Universal Battery Limiter is available through the Snap Store.\n\n"
                      "You can update using:\n"
                      "â€¢ Snap Store app (recommended)\n"
                      "â€¢ Terminal: sudo snap refresh universal-battery-limiter\n\n"
                      "Would you like to open Snap Store?")
            command = ["snap-store"]
        else:
            return

        dialog = Gtk.MessageDialog(
            parent=None,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.YES_NO,
            text=title
        )

        dialog.format_secondary_text(message)

        response = dialog.run()
        if response == Gtk.ResponseType.YES:
            try:
                subprocess.Popen(command)
            except FileNotFoundError:
                # Fallback to terminal command
                if update_method == "apt":
                    subprocess.Popen(["gnome-terminal", "--", "sudo", "apt", "update", "&&", "sudo", "apt", "upgrade", "universal-battery-limiter"])
                elif update_method == "snap":
                    subprocess.Popen(["gnome-terminal", "--", "sudo", "snap", "refresh", "universal-battery-limiter"])

        dialog.destroy()

    def compare_versions(self, version1, version2):
        """Compare two version strings. Returns True if version1 > version2"""
        try:
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]

            # Pad shorter version with zeros
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))

            return v1_parts > v2_parts
        except:
            return False

    def show_update_dialog(self, latest_version, release_url, release_notes):
        """Show update available dialog"""
        dialog = Gtk.MessageDialog(
            parent=None,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.YES_NO,
            text="Update Available!"
        )

        dialog.format_secondary_text(
            f"A new version ({latest_version}) is available!\n"
            f"Current version: {self.current_version}\n\n"
            f"Release Notes:\n{release_notes[:200]}{'...' if len(release_notes) > 200 else ''}\n\n"
            f"Would you like to open the download page?"
        )

        response = dialog.run()
        if response == Gtk.ResponseType.YES:
            subprocess.Popen(["xdg-open", release_url])

        dialog.destroy()

    def show_channel_settings(self, widget):
        """Show release channel settings dialog"""
        dialog = Gtk.Dialog(title="Release Channel Settings", 
                           parent=None, 
                           flags=0)
        dialog.add_buttons("Cancel", Gtk.ResponseType.CANCEL,
                          "Apply", Gtk.ResponseType.OK)
        
        dialog.set_default_size(400, 200)
        
        content_area = dialog.get_content_area()
        content_area.set_spacing(10)
        content_area.set_margin_left(20)
        content_area.set_margin_right(20)
        content_area.set_margin_top(20)
        content_area.set_margin_bottom(20)
        
        # Title
        title_label = Gtk.Label()
        title_label.set_markup("<b>Choose Release Channel</b>")
        content_area.pack_start(title_label, False, False, 0)
        
        # Description
        desc_label = Gtk.Label()
        desc_label.set_text("Select which type of updates you want to receive:")
        desc_label.set_line_wrap(True)
        content_area.pack_start(desc_label, False, False, 0)
        
        # Radio buttons
        stable_radio = Gtk.RadioButton.new_with_label_from_widget(None, "Stable")
        stable_desc = Gtk.Label()
        stable_desc.set_text("   â€¢ Stable, tested releases\n   â€¢ Recommended for most users")
        stable_desc.set_halign(Gtk.Align.START)
        
        beta_radio = Gtk.RadioButton.new_with_label_from_widget(stable_radio, "Beta")
        beta_desc = Gtk.Label()
        beta_desc.set_text("   â€¢ Early access to new features\n   â€¢ May contain bugs")
        beta_desc.set_halign(Gtk.Align.START)
        
        # Set current selection
        if self.release_channel == "stable":
            stable_radio.set_active(True)
        else:
            beta_radio.set_active(True)
        
        content_area.pack_start(stable_radio, False, False, 0)
        content_area.pack_start(stable_desc, False, False, 0)
        content_area.pack_start(beta_radio, False, False, 0)
        content_area.pack_start(beta_desc, False, False, 0)
        
        # Current channel info
        current_label = Gtk.Label()
        current_label.set_markup(f"<i>Current channel: {self.release_channel.title()}</i>")
        content_area.pack_start(current_label, False, False, 10)
        
        dialog.show_all()
        
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            new_channel = "stable" if stable_radio.get_active() else "beta"
            if new_channel != self.release_channel:
                self.release_channel = new_channel
                self.save_settings()
                self.show_notification("Channel Changed", 
                                     f"Release channel changed to {new_channel.title()}")
        
        dialog.destroy()

    def save_settings(self):
        """Save settings to file"""
        try:
            import os
            config_dir = os.path.expanduser("~/.config/universal-battery-limiter")
            os.makedirs(config_dir, exist_ok=True)
            
            config_file = os.path.join(config_dir, "settings.conf")
            with open(config_file, 'w') as f:
                f.write(f"release_channel={self.release_channel}\n")
        except Exception as e:
            print(f"Failed to save settings: {e}")

    def load_settings(self):
        """Load settings from file"""
        try:
            import os
            config_file = os.path.expanduser("~/.config/universal-battery-limiter/settings.conf")
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    for line in f:
                        if line.startswith("release_channel="):
                            self.release_channel = line.split("=")[1].strip()
        except Exception as e:
            print(f"Failed to load settings: {e}")

    def about_dialog(self, widget):
        dialog = Gtk.AboutDialog()
        dialog.set_name("Universal Battery Limiter")
        dialog.set_version("2.0.0")
        dialog.set_comments("Battery charge limit management for all compatible laptops")
        dialog.set_website("https://github.com/FrancyAlinston/Laptop-Battery-Limiter")
        dialog.set_authors(["FrancyAlinston"])
        dialog.set_license_type(Gtk.License.MIT_X11)
        dialog.run()
        dialog.destroy()

    def start_update_thread(self):
        def update_loop():
            while True:
                time.sleep(30)  # Update every 30 seconds
                GObject.idle_add(self.update_indicator)

        thread = threading.Thread(target=update_loop)
        thread.daemon = True
        thread.start()

    def quit(self, widget):
        Notify.uninit()
        Gtk.main_quit()

def main():
    indicator = BatteryLimitIndicator()
    Gtk.main()

if __name__ == "__main__":
    main()
